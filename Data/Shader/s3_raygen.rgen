#version 460
#extension GL_GOOGLE_include_directive : enable
#extension GL_NV_ray_tracing : require
#include "RayCommon.glsl"

layout(binding = 0, set = 0) uniform accelerationStructureNV topLevelAS;
layout(binding = 1, set = 0, rgba8) uniform image2D image;

layout(location = 0) rayPayloadNV RP hitValue;

#define LOOP 3
#define PixelRay 2
void main()
{
    const vec2 pixelCenter = vec2(gl_LaunchIDNV.xy) + vec2(0.5);
    const vec2 inUV = pixelCenter / vec2(gl_LaunchSizeNV.xy);
    vec2 d = inUV * 2.0 - 1.0;

    vec4 origin = cam.viewInverse * vec4(0, 0, 0, 1);
    vec4 target = cam.projInverse * vec4(d.x, d.y, 1, 1);
    vec4 direction = cam.viewInverse * vec4(normalize(target.xyz), 0);

    uint rayFlags = gl_RayFlagsOpaqueNV;
    uint cullMask = 0xff;
    float tmin = 0.001;
    float tmax = 10000.0;
    vec3 record[LOOP];
    for (int i = 0; i < LOOP; i++) {
        record[i] = vec3(0);
    }
    vec3 result = vec3(0.0, 0.0, 0.0);
    for (int r = 0; r < PixelRay; r++) {
        hitValue.position = origin.xyz;
        hitValue.direction = direction.xyz;
        hitValue.bias = float(r);
        for (int i = 0; i < LOOP; i++) {
            traceNV(topLevelAS, rayFlags, cullMask, 0, 0, 0, hitValue.position, tmin, hitValue.direction, tmax, 0);
            if (hitValue.color.x < 0) {
                break;
            }
            record[i] = hitValue.color + 0.;
            result = result*0.9 + record[i];
        }
    }
    result /= float(PixelRay);
    // result = result / (result + vec3(1.0));
    // result = pow(result, vec3(1.0 / 2.2));
    imageStore(image, ivec2(gl_LaunchIDNV.xy), vec4(result, 0.0));
}
