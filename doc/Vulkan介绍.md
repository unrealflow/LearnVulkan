# Vulkan介绍


## 背景

随着显卡架构的逐渐成熟，渲染管线中的可编程功能越来越多，这些功能被集成到原有的API中。因此，驱动程序要做的工作也越来越复杂，应用程序要处理的兼容性问题也越来越多。随着移动浪潮的到来，人们对移动端渲染的要求越来越高，但以往的图形API不能够进行更加精准的控制来提升渲染效率，对多线程的支持也非常不足，没有发挥出图形硬件真正的潜力。

随着版本的迭代，DirectX逐渐将更多的底层细节暴露出来，而OpenGL受基础架构设计限制，越来越难以提升。受到AMD的Mantle的启发，Khronos组织决心抛弃OpenGL的历史包袱，重新开发一个新的图形API，这就是Vulkan。

由于没有历史包袱，Vulkan 完全按照现代图形架构设计，提供了更加详细的 API 给开发者，大大减少了驱动程序的开销，允许多个线程并行创建和提交指令，使用标准化的着色器字节码，将图形和计算功能进行统一。

Vulkan最早由Khronos组织在2015年游戏开发者大会（GDC）上发表，于2016年2月正式发布第一个版本。由于发布时间较短，学习及使用难度较大，目前仍没有得到大规模应用，但已有不少企业进行vulkan的尝试。不少游戏引擎如Unreal Engine 4、Unity 3D 、CryEngine V、Source 2等相继添加Vulkan支持，一些3D建模软件如Blender等也将Vulkan加入到开发计划。

## 传统图形 API: Direct3D\OpenGL

### 简介

传统 API 诞生于 90 年代，至今已经近30年。其设计哲学主要以兼容性、易用性。Direct3D 是微软 DirectX 体系中的一个组件，主要用于 3D 实时渲染功能，OpenGL 是 Khronos 组织推出的用于实时渲染的图形 API，OpenGL ES 是该组织在 OpenGL 基础上简化的用于在移动平台实时渲染 API。

### 特点

* 管线状态是隐式的、全局的：管线的当前状态隐藏在 API（Runtime\Driver）内部，应用程序无法精准的控制管线当前状态。

* 频繁的 API 调用：由于整个图形 API 渲染管线是基于状态的，所以应用程序必须频繁的调用 API 来设置管线状态和恢复状态。

* 状态切换开销：传统 API 会对每个渲染状态的设置进行校验和二次处理，比如合并状态统一提交，这样就造成了状态的切换也有一定的开销，减少状态的切换往往是传统 API 的应用必须要考虑的事情。

* 复杂的驱动层逻辑：传统 API 的 Driver 往往都带有非常复杂的逻辑，在 Driver 内部维护跟踪状态，自动管理资源及调度，以及进行运行时的校验，以保证渲染正确。同时，驱动程序还需要提供错误接口、负责CPU与GPU的同步等工作，这些工作均增加了CPU开销。由于不同的硬件厂商的驱动处理这些工作的方式都不一样，所以App在不同显卡上运行的症状以及优化的方式都会有差别，这也让开发者难以对程序进行优化。

* 隐式的资源状态管理：传统的 API 的内存管理是隐式的，当创建资源时 Runtime\Driver 内部也同时创建用于这个资源的内存，这个过程对开发者是透明的，尽管接口简单，但带来的问题是很难优化内存分配，并且容易造成 GPU 内存碎片。为了维护渲染时资源状态的正确，Runtime\Driver会通过提示、假设或猜想等方式，使用 GPU 内部的同步机制进行自动的状态跟踪和维护。这样的行为导致应用程序无法深入到内部以最优化的方式减少同步，也无法进一步提升同步性能。

* 隐式的渲染工作提交：传统 API 渲染工作的提交一般情况下是 Runtime\Driver 内部执行的，这种隐式的机制导致应用程序很难做到最优化的 CPU、GPU 同步。

* 难以利用多线程：由于管线的状态与单一线程绑定，所有需要改变管线状态的操作都只能在单一线程上进行。

在现在的各种图形程序中，随着显卡性能的逐步提升，呈现出的画面也更加精美，但与此同时，复杂的场景、大量的网格物体、多种材质、复杂的渲染管线等要求在每一帧进行大量的状态更新，资源绑定操作所花费的计算时间就不能被简单的忽略了。在处理这些修改管线状态的操作时，驱动会在后台运行许多工作，包括下载纹理，资源访问的同步，渲染状态组合正确性验证，以及错误检查等等等等。对于3D App开发者来说，这些工作什么时候发生，是否发生，都是在API层面无法确定的。所以这样的结果就是在CPU端造成卡顿。卡顿也许是你第一次给管线绑定特定的Shader，VBO或者Blend Mode，Render Target的时候。由于不同的硬件厂商的驱动处理这些工作的方式都不一样，所以App在不同显卡上运行的症状以及优化的方式都会有差别，优化也是无从下手。

传统图形API的另一个问题就是，并不多线程友好。现在多核的系统以及不能再更加普及，然而大多数的图形应用和游戏在CPU端并没有将这些放在手边的计算资源利用起来。当在驱动的工作非常费时的情况下，利用CPU端的多线程非常可能有效的提高整个程序的性能。

无论OpenGL还是Direct3D，都包含一个Context的概念。Context包括当前渲染管线中的所有状态，绑定的Shader，Render Target等。在OpenGL中Context和单一线程是绑定的，所以所有需要作用于Context的操作，例如改变渲染状态，绑定Shader，调用Draw Call，都只能在单一线程上进行。`NV_CommandList`拓展可以让App支持多线程的任务生成，但是所有渲染状态的操作还是只能在主线程进行。在Direct3D中，多个线程访问Context时需要App显示的做Synchronization，程序写起来比较麻烦，而且也会有一定性能的影响。

## 现代图形 API：Direct3D12\Vulkan\Metal

### 简介

随着硬件的发展和新渲染技术的出现，传统 API 也在不断进化，但为了保持兼容性，接口越来越复杂，甚至同一个功能可以有多个方式实现，造成驱动维护上的困难以及开发者使用上的困惑，与当初的设计思想偏离越来越远，甚至是矛盾的，业界迫切需要适应现代图形硬件的，满足复杂渲染需求的全新图形 API。在此背景下，微软发布了全新一代图形 API 组件 Direct3D 12，Apple 发布了运行于 iOS\MacOS 平台的全新的图形 API Metal，Khronos组织也发布了 OpenGL 的继任者：Vulkan。

现代的 API 以更加显式的管理、更贴近于硬件的接口，给与开发者更大的自由度为其指导设计哲学。从接口来看，Vulkan 和 Metal 是全新的 API 设计，D3D12 的绝大部分的接口都重新设计，少量还存在的接口的概念也不尽相同。

### 特点

* 低消耗的状态切换：新 API 使用 PipelineState 将管道状态提前创建并绑定，在渲染时，通过设置不同的 PipelineState，Driver 只需要少量的切换开销即可将预先创建的状态绑定到 GPU 中，而无需像传统 API 那样校验每种状态有效性以及动态合并状态，从而降低了绘制调用开销，并且可以大幅增加每帧的绘制调用次数。

* 预置的 Shader 资源布局和绑定：通过 RootSingature（D3D12）或者 PipelineLayout（Vulkan）通过 Descriptor 预先设置好 Shader 所需要使用的资源布局信息，包括：Constant、Texture（SRV）、Buffer（UAV）、Sampler 等，在渲染时 Shader 通过 DescriptorTable 或者 DescriptorSet 用间接寻址方式获取资源，无需渲染时绑定，大大降低了资源绑定和校验开销，从而提高了渲染性能。

* 显式的资源状态管理：现代 API 都提供了 CPU/GPU 堆内存管理接口，可以通过创建堆，在堆上分配空间的方式来创建资源，应用程序可以精准的控制资源堆内存的分配；通过使用资源屏障（Resource Barrier）来要求应用层明确控制资源的状态迁移， Runtime\Driver 不再进行自动的状态跟踪和维护，而是完全由开发者来管理资源状态。这使得开发者能很明确的了解所使用的资源当前状态，可以更高效的控制状态迁移，从而提升性能。同时，新API要求应用程序手动进行资源的释放，并确保渲染命令不再使用资源时才能释放，虽然增加了资源管理的复杂度，但大大提升了资源生命周期的控制精度。

* 显式的渲染工作提交和 CPU/GPU 同步控制：应用程序通过使用 Command List（D3D12）或 Command Buffer（Vulkan\Metal）录制渲染命令，再通过 Command Queue 提交到 GPU 中执行。CPU 和 GPU 的同步是通过 Fence 对象和 WaitFence 函数完成，整个过程完全由应用程序来控制，这样应用程序可以根据需要，更加精准的控制同步时机，从而实现 CPU/GPU 最大化并行性能。由于不同的指令可以使用不同的线程中来录制，不同的Command Queue也彼此独立，这样的设计也可以充分发挥现代 CPU 多核的并行能力。

## Vulkan的设计哲学

Vulkan，亦或者Direct3D 12的诞生都是为了摆脱传统图形API的局限。Vulkan的API在设计上很明显的可以看到以下几个思路：

* 更依赖于程序自身的认知，让程序有更多的权限和责任自主的处理调度和优化，而不依赖于驱动尝试在后台的优化。程序开发者应该程序的最优化行为最为了解，传统图形API则靠驱动分析程序中调用API模式来揣测并且推断所有操作的优化方法。
  
* 多线程友好。让程序尽可能的利用所有CPU计算资源从而提高性能。Vulkan中不再需要依赖于绑定在某个线程上的Context，而是用全新的基于Queue的方式向GPU递交任务，并且提供多种用于同步的组件让多线程编程更加亲民。
  
* 强调复用，从而减少开销。大多数Vulkan API的组件都可以高效的被复用。

由于这些原因，Vulkan难以使用，并且在一定程度上很不稳定。你需要做大量的工作来保证Vulkan运行正常，并且API的错误使用经常会导致图形错乱甚至程序崩溃，而在传统的图形API里你通常会提前收到用于帮助解决问题的错误消息。以此为代价，Vulkan提供了对设备的更多控制、清晰的线程模型以及比传统API高得多的性能。

## Vulkan的基础架构

对于绘制一个简单的三角形，Vulkan应用程序的基础步骤包括：

1. 创建实例和选择物理设备
    Vulkan应用程序是通过`VkInstance`来使用Vulkan API的。应用程序创建`VkInstance`后，可以查询Vulkan支持的硬件设备。通过检查设备的各项支持属性，选择一个或多个合适的`VkPhysicalDevice`进行操作，例如查询显卡的显存大小和优先使用独立显卡。

2. 创建逻辑设备和队列族
    选择完合适的硬件设备后，Vulkan应用程序可根据更详细的需要使用的设备特性来创建一个逻辑设备`VKDevice`，同时程序也需要指定要使用的队列族。Vulkan中，像绘制指令和内存操作等的许多操作，需要提交到队列`VkQueue`中，并进行异步执行。队列由队列族分配，每个队列族支持一个特定的操作集合。在选择物理设备时可以将设备队列族作为参考。某些支持Vulkan的设备可能没有提供任何图形功能，但支持Vulkan的显卡设备一般支持所有的队列操作。

3. 创建窗口、窗口表面和交换链
    在进行非离屏渲染的一般渲染任务时，我们需要创建一个窗口来显示渲染的图像。这一工作可以由平台的原生窗口API或像GLFW、SDL之类的库来完成。Vullan API本身是与平台无关的，程序需要通过WSI（Window System Interface）扩展与窗口交互。窗口表面`VkSurfaceKHR`是一个跨平台的抽象，通常由原生窗口句柄作为参数实例化得到。交换链`VkSwapchainKHR`是一个渲染目标的集合，用于管理多个图像，以使在窗口呈现图像时进行后续帧的渲染。

4. 创建图像视图和帧缓冲
    交换链中的图像需要包装进图像视图`VkImageView`和帧缓冲`VkFrameBuffer`中才能进行绘制。一个图像视图可以引用图像的特定部分，一个帧缓冲可以引用图像视图作为渲染目标。交换链中一般由多个图像，程序需要为每个图像创建图像视图和帧缓冲，并在渲染时选择当前渲染图像相应的视图和帧缓冲。

5. 创建渲染流程
    Vulkan中的渲染流程`VkRenderPass`描述了渲染操作的图像类型、图像的使用方式、图像内容的处理。渲染流程还描述了多个子流程的依赖关系。

6. 创建图形管线
    Vulkan中的图形管线`VkPipeline`描述了显卡的可配置状态，并为可编程阶段加载Shader。程序可提前创建出所有需要的图形管线，在渲染时直接使用已经创建好的图形管线，从而减少渲染时状态的切换开销，也可以减少错误的发生。

7. 创建指令池和记录指令缓冲
    对于Vulkan中一些提交到队列执行的操作，需要先将这些操作记录到一个指令缓冲`VkCommandBuffer`中，然后才能提交给队列。指令缓冲由一个关联了特定队列族的指令池`VkCommandPool`分配而来。为了绘制图像，程序可以提前将开始渲染、绑定图形管线、绑定顶点缓冲等指令记录到指令缓冲，在渲染时仅进行指令缓冲的循环提交。

8. 主循环
    由于预先将绘制指令记录至指令缓冲，主循环可以通过`vkAcquireNextImageKHR`函数从交换链获取图像索引，并提交对应的指令缓冲，再将渲染图像返回给交换链，显示图像到屏幕。由于队列的提交操作会被异步执行，因此需要使用信号量、栅栏等同步措施保证操作的正确顺序。

9. 资源的释放和清除
    Vulkan需要程序自己管理内存资源，因此在渲染任务结束时，需要手动将创建的设备、图像等资源按照合适的顺序释放。



## References

* [游戏引擎随笔 0x05：现代图形 API 讲义](https://zhuanlan.zhihu.com/p/73016473)

* [Vulkan - 高性能渲染](https://zhuanlan.zhihu.com/p/20712354)

* [Vulkan编程指南(章节2-概述)](https://zhuanlan.zhihu.com/p/56377461)
