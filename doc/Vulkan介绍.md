# Vulkan介绍


## 背景

随着显卡架构的逐渐成熟，渲染管线中的可编程功能越来越多，这些功能被集成到原有的API中。因此，驱动程序要做的工作也越来越复杂，应用程序要处理的兼容性问题也越来越多。随着移动浪潮的到来，人们对移动端渲染的要求越来越高，但以往的图形API不能够进行更加精准的控制来提升渲染效率，对多线程的支持也非常不足，没有发挥出图形硬件真正的潜力。

随着版本的迭代，DirectX逐渐将更多的底层细节暴露出来，而OpenGL受基础架构设计限制，越来越难以提升。受到AMD的Mantle的启发，Khronos组织决心抛弃OpenGL的历史包袱，重新开发一个新的图形API，这就是Vulkan。

由于没有历史包袱，Vulkan 完全按照现代图形架构设计，提供了更加详细的 API 给开发者，大大减少了驱动程序的开销，允许多个线程并行创建和提交指令，使用标准化的着色器字节码，将图形和计算功能进行统一。

Vulkan最早由Khronos组织在2015年游戏开发者大会（GDC）上发表，于2016年2月正式发布第一个版本。由于发布时间较短，学习及使用难度较大，目前仍没有得到大规模应用，但已有不少企业进行vulkan的尝试。不少游戏引擎如Unreal Engine 4、Unity 3D 、CryEngine V、Source 2等相继添加Vulkan支持，一些3D建模软件如Blender等也将Vulkan加入到开发计划。

## 传统图形API的局限

在渲染循环中，通常每一帧都会有好几个render pass，例如shadow map和gbuffer的渲染，光照以及各种后处理等。每个pass都有需要设定特定的管线状态，例如blending，depth，raster的状态等等。在下面几层循环中通畅需要遍历所有的shader和着色系统需要的材质参数，如纹理，常量等等。在最内层的循环中，则是需要遍历共享材质的几何体，在这里同场需要绑定vertex buffer和index buffer，以及针对物体的常量参数例如矩阵等。

在现在的各种图形程序中，随着显卡性能的逐步提升，呈现出的画面也更加精美，但与此同时，复杂的场景、大量的网格物体、多种材质、复杂的渲染管线等要求在每一帧进行大量的状态更新，资源绑定操作所花费的计算时间就不能被简单的忽略了。

在处理这些修改管线状态的操作时，驱动会在后台运行许多工作，包括下载纹理，资源访问的同步，渲染状态组合正确性验证，以及错误检查等等等等。对于3D App开发者来说，这些工作什么时候发生，是否发生，都是在API层面无法确定的。所以这样的结果就是在CPU端造成卡顿。卡顿也许是你第一次给管线绑定特定的Shader，VBO或者Blend Mode，Render Target的时候。由于不同的硬件厂商的驱动处理这些工作的方式都不一样，所以App在不同显卡上运行的症状以及优化的方式都会有差别，优化也是无从下手。

传统图形API的另一个问题就是，并不多线程友好。现在多核的系统以及不能再更加普及，然而大多数的图形应用和游戏在CPU端并没有将这些放在手边的计算资源利用起来。当在驱动的工作非常费时的情况下，利用CPU端的多线程非常可能有效的提高整个程序的性能。

无论OpenGL还是Direct3D，都包含一个Context的概念。Context包括当前渲染管线中的所有状态，绑定的Shader，Render Target等。在OpenGL中Context和单一线程是绑定的，所以所有需要作用于Context的操作，例如改变渲染状态，绑定Shader，调用Draw Call，都只能在单一线程上进行。`NV_CommandList`拓展可以让App支持多线程的任务生成，但是所有渲染状态的操作还是只能在主线程进行。在Direct3D中，多个线程访问Context时需要App显示的做Synchronization，程序写起来比较麻烦，而且也会有一定性能的影响。

## Vulkan的设计哲学

Vulkan，亦或者Direct3D 12的诞生都是为了摆脱以上提到的局限。Vulkan的API在设计上很明显的可以看到以下几个思路：

* 更依赖于程序自身的认知，让程序有更多的权限和责任自主的处理调度和优化，而不依赖于驱动尝试在后台的优化。程序开发者应该程序的最优化行为最为了解，传统图形API则靠驱动分析程序中调用API模式来揣测并且推断所有操作的优化方法。
  
* 多线程友好。让程序尽可能的利用所有CPU计算资源从而提高性能。Vulkan中不再需要依赖于绑定在某个线程上的Context，而是用全新的基于Queue的方式向GPU递交任务，并且提供多种用于同步的组件让多线程编程更加亲民。
  
* 强调复用，从而减少开销。大多数Vulkan API的组件都可以高效的被复用。

Vulkan是个显式的API，也就是说，几乎所有的事情你都需要亲自负责。驱动程序是一个软件，用于接收API调用传递过来的指令和数据，并将它们进行转换，使得硬件可以理解。在老的API（例如OpenGL）里，驱动程序会跟踪大量对象的状态，自动管理内存和同步，以及在程序运行时检查错误。这对开发人员非常友好，但是在应用程序经过调试并且正确运行时，会消耗宝贵的CPU性能。Vulkan解决这个问题的方式是，将状态跟踪、同步和内存管理交给了应用程序开发人员，同时将正确性检查交给各个层进行代理，而要想使用这些层必须手动启用。这些层在正常情况下不会在应用程序里执行。

由于这些原因，Vulkan难以使用，并且在一定程度上很不稳定。你需要做大量的工作来保证Vulkan运行正常，并且API的错误使用经常会导致图形错乱甚至程序崩溃，而在传统的图形API里你通常会提前收到用于帮助解决问题的错误消息。以此为代价，Vulkan提供了对设备的更多控制、清晰的线程模型以及比传统API高得多的性能。

## Vulkan的基础架构

对于绘制一个简单的三角形，Vulkan应用程序的基础步骤包括：

1. 创建实例和选择物理设备
    Vulkan应用程序是通过`VkInstance`来使用Vulkan API的。应用程序创建`VkInstance`后，可以查询Vulkan支持的硬件设备。通过检查设备的各项支持属性，选择一个或多个合适的`VkPhysicalDevice`进行操作，例如查询显卡的显存大小和优先使用独立显卡。

2. 创建逻辑设备和队列族
    选择完合适的硬件设备后，Vulkan应用程序可根据更详细的需要使用的设备特性来创建一个逻辑设备`VKDevice`，同时程序也需要指定要使用的队列族。Vulkan中，像绘制指令和内存操作等的许多操作，需要提交到队列`VkQueue`中，并进行异步执行。队列由队列族分配，每个队列族支持一个特定的操作集合。在选择物理设备时可以将设备队列族作为参考。某些支持Vulkan的设备可能没有提供任何图形功能，但支持Vulkan的显卡设备一般支持所有的队列操作。

3. 创建窗口、窗口表面和交换链
    在进行非离屏渲染的一般渲染任务时，我们需要创建一个窗口来显示渲染的图像。这一工作可以由平台的原生窗口API或像GLFW、SDL之类的库来完成。Vullan API本身是与平台无关的，程序需要通过WSI（Window System Interface）扩展与窗口交互。窗口表面（`VkSurfaceKHR`）是一个跨平台的抽象，通常由原生窗口句柄作为参数实例化得到。交换链（VkSwapchainKHR）是一个渲染目标的集合，用于管理多个图像，以使在窗口呈现图像时进行后续帧的渲染。

4. 创建图像视图和帧缓冲
    交换链中的图像需要包装进图像视图VkImageView和帧缓冲VkFrameBuffer中才能进行绘制。一个图像视图可以引用图像的特定部分，一个帧缓冲可以引用图像视图作为渲染目标。交换链中一般由多个图像，程序需要为每个图像创建图像视图和帧缓冲，并在渲染时选择当前渲染图像相应的视图和帧缓冲。

5. 创建渲染流程
    Vulkan中的渲染流程（VkRenderPass）描述了渲染操作的图像类型、图像的使用方式、图像内容的处理。渲染流程还描述了多个子流程的依赖关系。

6. 创建图形管线
    Vulkan中的图形管线（VkPipeline）描述了显卡的可配置状态，并为可编程阶段加载Shader。程序可提前创建出所有需要的图形管线，在渲染时直接使用已经创建好的图形管线，从而减少渲染时状态的切换开销，也可以减少错误的发生。

7. 创建指令池和记录指令缓冲
    对于Vulkan中一些提交到队列执行的操作，需要先将这些操作记录到一个指令缓冲（VkCommandBuffer）中，然后才能提交给队列。指令缓冲由一个关联了特定队列族的指令池（VkCommandPool）分配而来。为了绘制图像，程序可以提前将开始渲染、绑定图形管线、绑定顶点缓冲等指令记录到指令缓冲，在渲染时仅进行指令缓冲的循环提交。

8. 主循环
    由于预先将绘制指令记录至指令缓冲，主循环可以通过vkAcquireNextImageKHR函数从交换链获取图像索引，并提交对应的指令缓冲，再将渲染图像返回给交换链，显示图像到屏幕。由于队列的提交操作会被异步执行，因此需要使用信号量、栅栏等同步措施保证操作的正确顺序。

9. 资源的释放和清除
    Vulkan需要程序自己管理内存资源，因此在渲染任务结束时，需要手动将创建的设备、图像等资源按照合适的顺序释放。


