# Vulkan介绍


## 背景

随着DirectX版本的稳步迭代，OpenGL则在努力追赶，但越来越难以为继。受到AMD的Mantle的启发，Khronos组织决心抛弃OpenGL的历史包袱，重新开发一个新的图形API，这就是Vulkan。

Vulkan最早由Khronos组织在2015年游戏开发者大会（GDC）上发表，于2016年2月正式发布第一个版本。由于发布时间较短，学习及使用难度较大，目前仍没有得到大规模应用，但已有不少大企业进行vulkan的尝试。不少游戏引擎如Unreal Engine 4，Unity 3D ，CryEngine V，Source 2等相继添加Vulkan支持，一些3D建模软件如Blender等也将Vulkan加入到开发计划。

## 传统图形API的局限

在渲染循环中，通常每一帧都会有好几个render pass，例如shadow map和gbuffer的渲染，光照以及各种后处理等。每个pass都有需要设定特定的管线状态，例如blending，depth，raster的状态等等。在下面几层循环中通畅需要遍历所有的shader和着色系统需要的材质参数，如纹理，常量等等。在最内层的循环中，则是需要遍历共享材质的几何体，在这里同场需要绑定vertex buffer和index buffer，以及针对物体的常量参数例如矩阵等。

在现在的各种图形程序中，随着显卡性能的逐步提升，呈现出的画面也更加精美，但与此同时，复杂的场景、大量的网格物体、多种材质、复杂的渲染管线等要求在每一帧进行大量的状态更新，资源绑定操作所花费的计算时间就不能被简单的忽略了。

在处理这些修改管线状态的操作时，驱动会在后台运行许多工作，包括下载纹理，资源访问的同步，渲染状态组合正确性验证，以及错误检查等等等等。对于3D App开发者来说，这些工作什么时候发生，是否发生，都是在API层面无法确定的。所以这样的结果就是在CPU端造成卡顿。卡顿也许是你第一次给管线绑定特定的Shader，VBO或者Blend Mode，Render Target的时候。由于不同的硬件厂商的驱动处理这些工作的方式都不一样，所以App在不同显卡上运行的症状以及优化的方式都会有差别，优化也是无从下手。

传统图形API的另一个问题就是，并不多线程友好。现在多核的系统以及不能再更加普及，然而大多数的图形应用和游戏在CPU端并没有将这些放在手边的计算资源利用起来。当在驱动的工作非常费时的情况下，利用CPU端的多线程非常可能有效的提高整个程序的性能。

无论OpenGL还是Direct3D，都包含一个Context的概念。Context包括当前渲染管线中的所有状态，绑定的Shader，Render Target等。在OpenGL中Context和单一线程是绑定的，所以所有需要作用于Context的操作，例如改变渲染状态，绑定Shader，调用Draw Call，都只能在单一线程上进行。NV_CommandList拓展可以让App支持多线程的任务生成，但是所有渲染状态的操作还是只能在主线程进行。在Direct3D中，多个线程访问Context时需要App显示的做Synchronization，程序写起来比较麻烦，而且也会有一定性能的影响。

## Vulkan的设计哲学及架构

Vulkan，亦或者Direct3D 12的诞生都是为了摆脱以上提到的局限。Vulkan的API在设计上很明显的可以看到以下几个思路：

* 更依赖于程序自身的认知，让程序有更多的权限和责任自主的处理调度和优化，而不依赖于驱动尝试在后台的优化。程序开发者应该程序的最优化行为最为了解，传统图形API则靠驱动分析程序中调用API模式来揣测并且推断所有操作的优化方法。
  
* 多线程友好。让程序尽可能的利用所有CPU计算资源从而提高性能。Vulkan中不再需要依赖于绑定在某个线程上的Context，而是用全新的基于Queue的方式向GPU递交任务，并且提供多种Synchronization的组件让多线程编程更加亲民。
  
* 强调复用，从而减少开销。大多数Vulkan API的组件都可以高效的被复用。

Vulkan是一个用于图形和计算设备的编程接口。Vulkan设备通常由一个处理器和一定数量的固定功能硬件模块组成，用于加速图形和计算操作。通常，设备中的处理器是高度线程化的，所以在极大程度上Vulkan里的计算模型是基于并行计算的。Vulkan还可以访问运行应用程序的主处理器上的共享或非共享内存。Vulkan也会给开发人员提供这个内存。

Vulkan是个显式的API，也就是说，几乎所有的事情你都需要亲自负责。驱动程序是一个软件，用于接收API调用传递过来的指令和数据，并将它们进行转换，使得硬件可以理解。在老的API（例如OpenGL）里，驱动程序会跟踪大量对象的状态，自动管理内存和同步，以及在程序运行时检查错误。这对开发人员非常友好，但是在应用程序经过调试并且正确运行时，会消耗宝贵的CPU性能。Vulkan解决这个问题的方式是，将状态跟踪、同步和内存管理交给了应用程序开发人员，同时将正确性检查交给各个层进行代理，而要想使用这些层必须手动启用。这些层在正常情况下不会在应用程序里执行。

由于这些原因，Vulkan难以使用，并且在一定程度上很不稳定。你需要做大量的工作来保证Vulkan运行正常，并且API的错误使用经常会导致图形错乱甚至程序崩溃，而在传统的图形API里你通常会提前收到用于帮助解决问题的错误消息。以此为代价，Vulkan提供了对设备的更多控制、清晰的线程模型以及比传统API高得多的性能。