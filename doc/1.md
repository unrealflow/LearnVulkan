# Vulkan架构解析

## 关键概念

与OpenGL不同，Vulkan不会向应用程序添加任何全局状态，相关的状态信息会储存在程序创建的对象中，不同类型的对象用于储存不同方面的信息。

* `VkInstance`：Vulkan API可以看成应用程序中的一个子系统，VkInstance记录的则是这个子系统的整体状态，负责启用校验层、设置调试回调、实例层面上启用扩展等。同时也将一些自定义的信息如程序名称、版本等传递给显卡驱动。

* `VkPhysicalDevice`：代表支持Vulkan的物理设备，一般为显卡。可通过相关函数查询设备对不同功能的支持情况。

* `VkDevice`：显卡支持的特性和扩展很多，一般我们只会用到其中的一部分，因此，Vulkan通过创建逻辑设备，只启用部分功能和拓展，便于驱动对程序进行优化。

* `VkSurfaceKHR`：Vulkan自身API被设计成与平台无关的，通过不同的扩展与不同的平台进行交互。`VkSurfaceKHR`便代表不同平台上窗口的抽象。KHR后缀表示该对象是Vulkan的扩展。

* `VkSwapChianKHR`：在窗口呈现当前帧时，程序则在准备下一帧。当下一帧处理完毕后，交换链负责将当前的图像替换为下一帧的图像，包含要呈现图像的渲染目标的集合。

* `VkRenderPass`：代表一个绘制任务，往下可细分为多个`subpass`进行多个阶段的绘制。记录绘制中作为输入或输出的帧缓冲、GBuffer、深度缓冲等资源。

* `VkPipeline`：分为计算管线和图形管线。图形管线负责对固定功能管线进行设置、shader的编译链接、输入装配等任务。

* `VkDescriptorSet`：描述符集是作为整体绑定到管线的资源（`Uniform`、`Buffer`、`Image2D`等）的集合，每各描述符集都有自己的布局`VkDescriptorSetLayout`，管线使用到的所有的DescriptorSetLayout构成了管线的布局`VkPipelineLayout`。

* `VkCommandBuffer`：Vulkan中很多操作都无法让GPU立即执行，必须先记录到一个命令列表，再将命令列表提交给GPU，这样可有效地提高CPU与GPU地通信效率，也方便复用。`VkCommandBuffer`便是用于记录命令的列表。

* `VkQueue`：接收提交的`VkCommandBuffer`，并按照先后顺序执行。

## Vulkan程序的一般流程

1. 创建`VkInstance`
2. 创建窗口（`win32`、`GLFW`等），获取`VkSurfaceKHR`
3. 选择`VkPhysicalDevice`，创建`VkDevice`，获取`VkQueue`
4. 创建`VkSwapChainKHR`
5. 创建GBuffer、深度缓冲等附加缓冲
6. 创建`VkRenderPass`
7. 创建帧缓冲
8. 准备输入数据及输入数据的描述
9. 创建`VkPipelineLayout`和`VkPipeline`
10. 创建`VkDescriptorSet`并写入数据 
11. 创建并记录`VkCommandBuffer`
12. 开始循环提交`VkCommandBuffer`
13. 程序退出、进行资源的释放和清除

此处仅简要概述，详细步骤请参考一些文章和示例：  

* [官网：Vulkan Overview](https://www.khronos.org/vulkan/)

* [知乎：Vulkan编程指南- fangcun](https://zhuanlan.zhihu.com/c_1079388229215752192)

* [GitHub：SaschaWillems/Vulkan](https://github.com/SaschaWillems/Vulkan)

## 光线追踪扩展VK_NV_ray_tracing

关于光线追踪相关流程和理论请参考：
* [一篇光线追踪的入门 - 洛城](https://zhuanlan.zhihu.com/p/41269520)

NVIDIA推出RTX系列显卡，将光线追踪带至消费级显卡，也为Vulkan添加了光线追踪扩展 `VK_NV_ray_tracing`。

要使用`VK_NV_ray_tracing`扩展，需要NVIDIA RTX系列显卡或GTX1060以上显卡，Vulkan SDK版本1.1.92.1或更新版本。

RTX系列显卡需要NVIDIA显卡驱动版本416.82或更新版本。

GTX系列显卡则要求NVIDIA显卡驱动版本为425.31或更新版本。

该扩展为Vulkan加入一系列的概念和结构：
* `VkAccelerationStructureNV`：在光线与模型求交的过程中，不可能让光线与每个面片都进行求交测试，较常用的方法是先用一个简化的网格如正方形、球包裹整个模型，先检测光线是否与包围盒相交，只有相交时才会继续检测是否与里面的网格相交。依照这种思想，可以建立一个树状的、多层次的包围盒结构，可以显著的加速求交过程。
* `VkGeometryNV`：用来描述网格物体